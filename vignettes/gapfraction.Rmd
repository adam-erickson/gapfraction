---
title: "gapfraction: functions for processing airborne LiDAR scans of forests"
author: "Adam Erickson"
date: "April 1, 2016"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{"gapfraction: functions for processing airborne LiDAR scans of forests"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The **gapfraction** package is designed for processing airborne laser scanning (ALS) light-detection-and-ranging (LiDAR) data of forests. A version of the package was implemented in the final chapter of my doctoral dissertation at University of British Columbia^[Erickson, A. (2016) Forecasting Brown Bear (*Ursus Arctos*) Habitat Through the Integration of Remote Sensing, a Process-based Tree Establishment Model, and a Forest Landscape Model. University of British Columbia.]. The package is designed to be used with LiDAR data pre-processed with **LAStools**^[LAStools: http://rapidlasso.com/lastools/] or **USDA Fusion**^[USDA Fusion: http://forsys.cfr.washington.edu/fusion/fusionlatest.html]. The main input to functions in the gapfraction package are LAS format height-normalized point clouds, typically LiDAR plots corresponding to field plots. The compressed LAZ format is not yet supported, as I rely on the **rLiDAR** `readLAS` function for importing data^[Silva, Crookston, Hudak, and Vierling (2015). rLiDAR: LiDAR Data Processing and Visualization. R package version 0.1. https://CRAN.R-project.org/package=rLiDAR].

## Functions Included

The gapfraction package implements my new fast-pit-free canopy height model (CHM) algorithm based on Khosravipour et al. (2013)^[Khosravipour et al. (2013) Development of an algorithm to generate a LiDAR pit-free canopy height model. http://www.riegl.com/uploads/tx_pxpriegldownloads/khosravipour_SilviLaser2013.pdf], two new LiDAR metrics of canopy gap fraction ($P_o$) and angular canopy closure ($ACC$), several recent individual tree crown (ITC) detection methods, canopy distance and direction metrics, effective leaf area index ($L_e$) and apparent clumping index ($ACI$) estimation methods, as well as four mathematical fisheye (hemispherical) lens models: equi-angular, equi-distant, stereographic, and orthographic. An alphabetical list of functions in the gapfraction package is provided below.

- `chm` - Simple canopy height model
- `chm.pf` - Fast-pit-free canopy height model
- `dd.canopy` - Euclidean distance and direction to nearest canopy pixel from plot center
- `dd.crown` - Euclidean distance and direction to nearest tree crown from plot centers
- `fc.aci` - Above-height cover index of fractional canopy cover
- `fc.bl` - Beer-Lambert-Law-modified intensity-return ratio of fractional canopy cover
- `fc.cv` - 2-D Cartesian Voronoi fractional canopy cover
- `fc.fci` - First-echo cover index of fractional canopy cover
- `fc.fr` - Canopy-to-first-return ration of fractional canopy cover
- `fc.ir` - Intesity-return ratio of fractional canopy cover
- `fc.p` - Canopy-to-total-pixel ratio of fractional canopy cover
- `fc.r` - Canopy-to-total-return ratio of fractional canopy cover
- `fc.sci` - Solberg's cover index of fractional canopy cover
- `gf.hv` - Hemipsherical Voronoi canopy gap fraction
- `gf.hv.par` - Parallel hemispherical Voronoi canopy gap fraction with SOCKS
- `gf.laie.aci` - Point-density-normalized canopy gap fraction, effective LAI, and ACI
- `itc.mw` - Variable-window individual tree crown detection
- `itc.mw.h` - Hierarchical variable-window individual tree crown detection
- `itc.wat` - Watershed segmentation individual tree crown detection
- `itc.wat.h` - Hierarchical watershed segmentation individual tree crown detection
- `lai.e` - Ground-to-total-return ratio with a spherical leaf angle distribution
- `lai.n` - Contact frequency and fractional canopy cover-based effective LAI
- `radial.grid.hemi` - Modified radial.grid function supporting hemispherical lens geometries
- `sun.path` - Modified solar position plots of Thomas Steiner

## Equations Implemented

You can write math expressions:
$Y = X\beta + \epsilon$

$$\begin{align*}
\sum_{k=1}^n c x_k
&=cx_1+cx_2+\cdots+cx_n\\
&=c(x_1+x_2+\cdots+x_n)\\
&=c\sum_{k=1}^nx_k
\end{align*}$$

# Getting Started

## Data Pre-processing

For LiDAR data without ground point classifications, height-normalized point clouds can be produced either with two **LAStools** command line functions, `lasground` and `lasheight`, or with three functions in **USDA Fusion**, `GroundFilter`, `GridSurfaceCreate`, and `CanopyModel`. If the ground points are already classified then you only need to use the `lasheight` function of LAStools, while the process for Fusion still requires the same three functions. Hence, I recommend that you use LAStools. Besides, the LAStools ground point classification algorithm is superior to that of Fusion, producing more accurate height-normalized point clouds. That because Fusion uses the Kraus and Pfeifer (1998) algorithm^[Kraus and Pfeifer (1998) Determination of terrain models in wooded areas with airborne laser scanner data. http://www.sciencedirect.com/science/article/pii/S0924271698000094], while LAStools implements an optimized version of the Axelsson (1999) algorithm^[Axelsson (1999) Processing of laser scanner dataâ€”algorithms and applications. http://www.sciencedirect.com/science/article/pii/S0924271699000088]. For more information, read Maguya, Junttila, and Kauranne (2014)^[Maguya, Junttila, and Kauranne (2014) http://www.mdpi.com/2072-4292/6/7/6524]. An example application of `lasground` and `lasheight`, implemented in Command Prompt or Bash, is provided below. Very simple!

```
lasground -i lidar.las -o lidar_g.las 
lasheight -i lidar_g.las -o lidar_n.las -replace_z 
```

In order to run these functions, you need to istall **LAStools**. For Windows, don't forget to add the LAStools `bin` directory to your system path^[http://www.computerhope.com/issues/ch000549.htm]. For a single LiDAR plot, this is simple to run without leaving your R session. You can call these functions using the `system` function included in base R, as shown below.

```
setwd('C:/lidar')
system(lasground -i lidar.las -o lidar_g.las)
system(lasheight -i lidar_g.las -o lidar_n.las -replace_z)
```

To loop through LAS files stored in a folder, the syntax follows something like this:

```
folder <- 'C:/lidar'
files  <- list.files(folder, pattern="\\.las$", full.names=TRUE)

for (i in 1:length(files)) {
  file   <- files[i]
  basenm <- basename(file)
  filenm <- strsplit(basenm,'.',fixed=TRUE)[[1]][1]
  ground <- paste(folder,filenm,'_ground.las',sep='')
  htnorm <- paste(folder,filenm,'_norm.las',sep='')
  system(paste('lasground -i ',file,' -o ',ground, sep=''))
  while (!file.exists(ground)) { Sys.sleep(1) }
  system(paste('lasheight -i ',ground,' -o ',htnorm,' -replace_z', sep=''))
  while (!file.exists(htnorm)) { Sys.sleep(1) }
}
```
What this `for` loop does is read in each LAS file path, extract the name of the file without extension, create the filenames of the ground and height-normalized outputs, execute `lasground`, wait for the output, execute `lasheight` using the ground file as the input, wait for the output, then proceed to the next iteration. The code should be simple to parallelize using the `foreach` package, with each fork running in a new Command Prompt or Bash window.

## Example Data

After loading the gapfraction package with the `library` function, the example data can be loaded by calling `data(las)`. The included data consists of $X,Y,Z$ coordinates in UTM 11N and meters, along with 8-bit unsigned interger values for intensity and return number. The data represents a 100-meter diameter LiDAR plot in the foothills of western Alberta, Canada, where I conducted my PhD research. Based on previous research, I recommend using plots minimally of this size for comparison to ground data (e.g., hemispherical photography) to capture edge effects.

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.width=6, fig.height=6, echo=FALSE, warning=FALSE, message=FALSE)
```

```{r lastable, echo=FALSE, results='asis'}
require(gapfraction)
data(las)
knitr::kable(head(las,10))
```

Once the data is loaded, you can proceed to call functions from the `gapfraction` package.

## Example Usage

Comparison of canopy height model (CHM) algorithms.

```{r chmplots, echo=3:4, messages=FALSE, warnings=FALSE, verbose=FALSE, fig.show='hold', fig.width=6, fig.height=6}
require(gapfraction)
data(las)
chm(las)
chm.pf(las)
```

Creating a pit-free CHM and performing individual tree crown (ITC) detection with the standard variable-window and watershed algorithms.

```{r stditc, echo=4:5, messages=FALSE, warnings=FALSE, verbose=FALSE, fig.show='hold', fig.width=6, fig.height=6}
require(gapfraction)
data(las)
chm  <- chm.pf(las, silent=TRUE)
mw   <- itc.mw(chm, ht2rad=function(x) 0.15746*x)
wat  <- itc.wat(chm, ht2rad=function(x) 0.15746*x)
```

Creating a stacked pit-free CHM and performing individual tree crown (ITC) detection with the hierarchical variable-window and watershed algorithms.

```{r hieritc, echo=4:5, messages=FALSE, warnings=FALSE, verbose=FALSE}
require(gapfraction)
data(las)
chm  <- chm.pf(las, stacked=TRUE, silent=TRUE)
mw   <- itc.mw.h(chm, ht2rad=function(x) 0.15746*x, silent=TRUE)
wat  <- itc.wat.h(chm, ht2rad=function(x) 0.15746*x, silent=TRUE)
```

Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**.

## Styles

The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output: 
      rmarkdown::html_vignette:
        css: mystyles.css

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
